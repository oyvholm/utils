#!/usr/bin/env bash

#=======================================================================
# list-youtube
# File ID: c5f8c456-f24a-11e2-a3f1-001f3b596ec9
#
# Sort videos downloaded by youtube-dl in chronological order
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#=======================================================================

progname=list-youtube
VERSION=0.6.3

ARGS="$(getopt -o "\
d:\
f\
F:\
h\
o:\
q\
r\
S:\
v\
w:\
" -l "\
dbname:,\
filenames,\
from-file:,\
help,\
order-by:,\
quiet,\
reuse,\
sql:,\
verbose,\
version,\
where:,
" -n "$progname" -- "$@")"
test "$?" = "0" || exit 1
eval set -- "$ARGS"

opt_dbname=''
opt_filenames=0
opt_from_file=''
opt_help=0
opt_orderby=upload_date,file
opt_quiet=0
opt_reuse=0
opt_sql=''
opt_verbose=0
opt_where=''
while :; do
    case "$1" in
        -d|--dbname) opt_dbname="$2"; shift 2 ;;
        -f|--filenames) opt_filenames=1; shift ;;
        -F|--from-file) opt_from_file="$2"; shift 2 ;;
        -h|--help) opt_help=1; shift ;;
        -o|--order-by) opt_orderby="$2"; shift 2 ;;
        -q|--quiet) opt_quiet=$(($opt_quiet + 1)); shift ;;
        -r|--reuse) opt_reuse=1; shift ;;
        -S|--sql) opt_sql="$2"; shift 2 ;;
        -v|--verbose) opt_verbose=$(($opt_verbose + 1)); shift ;;
        -w|--where) opt_where="$2"; shift 2 ;;
        --version) echo $progname $VERSION; exit 0 ;;
        --) shift; break ;;
        *) echo $progname: Internal error >&2; exit 1 ;;
    esac
done
opt_verbose=$(($opt_verbose - $opt_quiet))

if test "$opt_help" = "1"; then
    test $opt_verbose -gt 0 && { echo; echo $progname $VERSION; }
    cat <<END

Sort videos downloaded by youtube-dl in chronological order

Usage: $progname [options]

Options:

  -d FILE, --dbname FILE
    Use FILE as database instead of storing it under 
    ~/.cache/$progname/[DIR].
  -f, --filenames
    List filenames instead of the default format with date and title. 
    Useful for creating playlists.
  -F FILE, --from-file FILE
    Read filenames from FILE instead of using find(1).
  -h, --help
    Show this help.
  -o COLUMN, --order-by COLUMN
    Sort output by COLUMN.
  -q, --quiet
    Be more quiet. Can be repeated to increase silence.
  -r, --reuse
    Reuse the database for the current directory, don't scan files and 
    create a new one.
  -S STATEMENT, --sql STATEMENT
    Execute SQL statement directly against the sqlite3 database. If 
    STATEMENT is "-", read commands from stdin or if stdin is empty, use 
    the sqlite3 shell. Examples:
      $progname -S .schema
      $progname -S "SELECT view_count AS v, file FROM yt ORDER BY v;"
      $progname -S -
      (echo .dbinfo; echo "SELECT file FROM yt;") | $progname -r -S -
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.
  -w CLAUSE, --where CLAUSE
    List only entries specified by CLAUSE.

END
    exit 0
fi

mkinsert() {
    echo "BEGIN;"
    sed "s/'/''/g; s/.*/INSERT INTO $1 VALUES('&');/;"
    echo "COMMIT;"
}

if test -n "$opt_dbname"; then
    db=$opt_dbname
else
    odir="$HOME/.cache/$progname$(pwd -P)"
    mkdir -p "$odir" || exit 1
    db="$odir/$progname.sqlite"
fi
if test "$opt_reuse" != "1" -o ! -e "$db"; then
    rm -f "$db" "$db-journal"
    cat <<SQL_END | sqlite3 "$db" || exit 1
CREATE TABLE t (file TEXT);
CREATE TABLE yt (
  average_rating REAL,
  description TEXT,
  dir TEXT,
  dislike_count INTEGER,
  display_id TEXT,
  duration INTEGER,
  extractor TEXT,
  file TEXT,
  filesize INTEGER,
  format TEXT,
  format_id TEXT,
  fulltitle TEXT,
  height INTEGER,
  length TEXT,
  like_count INTEGER,
  resolution TEXT,
  title TEXT,
  upload_date TEXT,
  uploader TEXT,
  uploader_id TEXT,
  view_count INTEGER,
  webpage_url TEXT,
  width INTEGER,
  ytid TEXT,
  j TEXT
);
SQL_END
    if test -n "$opt_from_file"; then
        grep '\.info\.json$' "$opt_from_file"
    else
        find -name '*.info.json'
    fi | mkinsert t | sqlite3 "$db"
    cat <<SQL_END | sqlite3 "$db"
BEGIN;
ALTER TABLE t ADD j TEXT;
UPDATE t SET j = json(readfile(file));
INSERT INTO yt
  SELECT
      json_extract(j, '$.average_rating') AS average_rating,
      json_extract(j, '$.description') AS description,
      NULL AS dir,
      json_extract(j, '$.dislike_count') AS dislike_count,
      json_extract(j, '$.display_id') AS display_id,
      json_extract(j, '$.duration') AS duration,
      json_extract(j, '$.extractor') AS extractor,
      file,
      json_extract(j, '$.filesize') AS filesize,
      json_extract(j, '$.format') AS format,
      json_extract(j, '$.format_id') AS format_id,
      json_extract(j, '$.fulltitle') AS fulltitle,
      json_extract(j, '$.height') AS height,
      NULL AS length,
      json_extract(j, '$.like_count') AS like_count,
      json_extract(j, '$.width') || 'x' || json_extract(j, '$.height')
        AS resolution,
      json_extract(j, '$.title') AS title,
      json_extract(j, '$.upload_date') AS upload_date,
      json_extract(j, '$.uploader') AS uploader,
      json_extract(j, '$.uploader_id') AS uploader_id,
      json_extract(j, '$.view_count') AS view_count,
      json_extract(j, '$.webpage_url') AS webpage_url,
      json_extract(j, '$.width') AS width,
      json_extract(j, '$.id') AS ytid,
      j
    FROM t;
UPDATE yt SET upload_date = substr(upload_date, 1, 4) || '-'
  || substr(upload_date, 5, 2) || '-' || substr(upload_date, 7, 2);
UPDATE yt SET length = printf('%02u:%02u:%02u',
                              duration / 3600,
                              duration / 60 % 60,
                              duration % 60);
COMMIT;
SQL_END
fi

if test -n "$opt_sql"; then
    if test "$opt_sql" = "-"; then
        sqlite3 "$db"
    else
        sqlite3 "$db" "$opt_sql" | $PAGER
    fi
    exit
fi

where_str='WHERE ytid IS NOT NULL'
if test -n "$opt_where"; then
    where_str="WHERE ($opt_where) AND ytid IS NOT NULL"
fi

if test "$opt_filenames" = "1"; then
    sqlite3 "$db" "DROP TABLE IF EXISTS films;"
    sqlite3 "$db" "CREATE TABLE films (file TEXT);"
    find | filmer | mkinsert films | sqlite3 "$db"
    cat <<SQL_END | sqlite3 "$db" | sqlite3 "$db"
SELECT 'BEGIN;';
SELECT printf('SELECT file FROM films WHERE file LIKE ''%%-%s%%'';', ytid)
  FROM yt
  $where_str
  ORDER BY $opt_orderby;
SELECT 'COMMIT;';
SQL_END
else
    cat <<SQL_END | sqlite3 -header -column "$db" | sed 's/ *$//g;' | $PAGER
.width 10 10 5 8 -11 20 200
SELECT
    upload_date AS ud,
    resolution,
    height,
    length,
    filesize,
    uploader,
    file
  FROM yt
  $where_str
  ORDER BY $opt_orderby;
SQL_END
fi
