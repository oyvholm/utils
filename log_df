#!/bin/sh

#==============================================================================
# log_df
# File ID: 99575e5c-5d3e-11df-9eee-90e6ba3022ac
#
# Log disk space.
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#==============================================================================

progname=log_df
VERSION=0.5.0

opt_dbname=''
opt_help=0
opt_quiet=0
opt_verbose=0
while test -n "$1"; do
	case "$1" in
	-d|--dbname) opt_dbname="$2"; shift 2 ;;
	-h|--help) opt_help=1; shift ;;
	-q|--quiet) opt_quiet=$(($opt_quiet + 1)); shift ;;
	-v|--verbose) opt_verbose=$(($opt_verbose + 1)); shift ;;
	--version) echo $progname $VERSION; exit 0 ;;
	--) shift; break ;;
	*)
		if printf '%s\n' "$1" | grep -q ^-; then
			echo "$progname: $1: Unknown option" >&2
			exit 1
		else
			break
		fi
	break ;;
	esac
done
opt_verbose=$(($opt_verbose - $opt_quiet))

if test "$opt_help" = "1"; then
	test $opt_verbose -gt 0 && { echo; echo $progname $VERSION; }
	cat <<END

Log disk space.

Usage: $progname [options]

Options:

  -d DBFILE, --dbname DBFILE
    Use DBFILE as database file for SQLite.
  -h, --help
    Show this help.
  -q, --quiet
    Be more quiet. Can be repeated to increase silence.
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.

END
	exit 0
fi

SQLITE=sqlite3
logdir="$HOME/log"
db="$logdir/df.sqlite"
dbversion=1
if test -n "$opt_dbname"; then
	db="$opt_dbname"
	logdir="$(dirname "$db")"
fi

[ -d "$logdir" ] || mkdir -p "$logdir" || {
	echo "$progname: $logdir: Could not create directory" >&2
	exit 1
}

sql_create_table_meta=$(cat <<SQL_END)
CREATE TABLE meta (
  key TEXT
    UNIQUE
    NOT NULL
  ,
  value TEXT
);
INSERT INTO meta VALUES ('dbversion', '$dbversion');
SQL_END

if test ! -f "$db"; then
	echo $progname: Creating database $db >&2
	cat <<SQL_END | $SQLITE "$db"
BEGIN EXCLUSIVE TRANSACTION;
$sql_create_table_meta
CREATE TABLE df (
  date TEXT
    CONSTRAINT df_date_length
      CHECK (length(date) = 19)
    CONSTRAINT df_date_valid
      CHECK (datetime(date) IS NOT NULL)
    NOT NULL
  ,
  mountp TEXT
    CONSTRAINT df_mountp_length
      CHECK (length(mountp) > 0)
    NOT NULL
  ,
  device TEXT
    CONSTRAINT df_device_length
      CHECK (length(device) > 0)
    NOT NULL
  ,
  size INTEGER
    CONSTRAINT df_size_length
      CHECK (length(size) > 0)
    CONSTRAINT df_size_positive
      CHECK (size >= 0)
    NOT NULL
  ,
  used INTEGER
    CONSTRAINT df_used_length
      CHECK (length(used) > 0)
    CONSTRAINT df_used_positive
      CHECK (used >= 0)
    NOT NULL
  ,
  free INTEGER
    CONSTRAINT df_free_length
      CHECK (length(free) > 0)
    CONSTRAINT df_free_positive
      CHECK (free >= 0)
    NOT NULL
  ,
  percent REAL
    CONSTRAINT df_percent_length
      CHECK (length(percent) > 0)
    CONSTRAINT df_percent_range
      CHECK (percent BETWEEN 0 AND 100)
    NOT NULL,
  UNIQUE (date, mountp)
);
CREATE TRIGGER nodups
  BEFORE INSERT ON df
  BEGIN
    SELECT RAISE (IGNORE)
      WHERE
        (SELECT used FROM df
          WHERE mountp = NEW.mountp
          ORDER BY date DESC
          LIMIT 1) = NEW.used;
  END;
COMMIT;
SQL_END
fi

curr_db_version=$(
    $SQLITE "$db" "SELECT value FROM meta WHERE key = 'dbversion';"
)

upgrade_db() {
	if test "$curr_db_version" = "$dbversion"; then
		echo $progname: Database $db is already version $dbversion >&2
		return 0
	fi
	echo $progname: Upgrading database $db to version $dbversion >&2
	backup="$db.$(date +"%Y%m%dT%H%M%SZ").db-upgrade.bck"
	if test -e "$backup"; then
		# Shouldn't happen, but keep it safe
		echo $progname: Database backup $backup already exists, \
		     aborting >&2
		return 1
	fi
	cp -p "$db" "$backup" || {
		echo $progname: Could not backup database $db to $backup >&2
		return 1
	}
	echo $progname: Database backup stored as $backup >&2

	sql="BEGIN EXCLUSIVE TRANSACTION;
"
	if test -z "$curr_db_version"; then
		# First version without meta table
		sql="$sql$(cat <<SQL_END)"
$sql_create_table_meta
SQL_END
	fi

	sql="$sql
COMMIT;"

	echo "$sql" | $SQLITE "$db" || return 1
	curr_db_version=$dbversion
	echo $progname: Database $db successfully upgraded \
	     to version $dbversion >&2
	return 0
}

if test -z "$curr_db_version"; then
	echo $progname: dbversion not found, upgrading database $db >&2
	upgrade_db || {
		echo $progname: Database upgrade failed
		exit 1
	}
fi

df -B 1 -P |
    grep ^/ |
    sort -u |
    perl -e "
while (<>) {
	chomp();
	if (/^(\\S+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\S+)%\\s+(\\S+)\$/) {
		my (\$device, \$size, \$used, \$free, \$percent, \$mountp) =
		   (     \$1,    \$2,    \$3,    \$4,       \$5,      \$6);
		print(
		    \"INSERT INTO df \" .
		      \"(date, mountp, device, size, used, free, percent) \" .
		      \"VALUES (\" .
		        \"datetime('now'), '\$mountp', '\$device', \" .
		        \"\$size, \$used, \$free, \$percent\" .
		      \");\\n\" .
		      \"\" .
		      \"\"
		);
	} else {
		warn(\"$progname: Invalid line: \\"\$_\\"\\n\");
	}
}
" | $SQLITE "$db"

# vim: set ts=8 sw=8 sts=8 noet fo+=w tw=79 fenc=UTF-8 :
