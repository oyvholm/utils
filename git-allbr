#!/bin/bash

#=======================================================================
# git-allbr
# File ID: b8c0ee54-eb71-11df-a07a-fefdb24f8e10
#
# Create local Git branches that only exist on remotes and update local 
# branches against remote branches.
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#=======================================================================

progname=git-allbr
VERSION=0.4.0

ARGS="$(getopt -o "\
a\
c\
f\
h\
q\
u\
v\
" -l "\
all,\
commit-branches,\
force,\
help,\
quiet,\
upstream,\
verbose,\
version,\
" -n "$progname" -- "$@")"
test "$?" = "0" || exit 1
eval set -- "$ARGS"

opt_all=0
opt_commit_branches=0
opt_force=0
opt_help=0
opt_quiet=0
opt_upstream=0
opt_verbose=0
while :; do
    case "$1" in
        (-a|--all) opt_all=1; shift ;;
        (-c|--commit-branches) opt_commit_branches=1; shift ;;
        (-f|--force) opt_force=1; shift ;;
        (-h|--help) opt_help=1; shift ;;
        (-q|--quiet) opt_quiet=$(($opt_quiet + 1)); shift ;;
        (-u|--upstream) opt_upstream=1; shift ;;
        (-v|--verbose) opt_verbose=$(($opt_verbose + 1)); shift ;;
        (--version) echo $progname $VERSION; exit 0 ;;
        (--) shift; break ;;
        (*) echo $progname: Internal error >&2; exit 1 ;;
    esac
done
opt_verbose=$(($opt_verbose - $opt_quiet))

if test "$opt_help" = "1"; then
    test $opt_verbose -gt 0 && { echo; echo $progname $VERSION; }
    cat <<END

Create local Git branches that only exist on remotes and update local 
branches against remote branches.

Usage: $progname [options] [remote [remotes [...]]]

Options:

  -a, --all
    Create branches from all remotes. If this option is not specified, 
    only "origin" or remotes specified on the command line are scanned.
  -c, --commit-branches
    Also create commit-* branches created by git-dangling.
  -f, --force
    Allow rewriting of local branches, override fast-forwarding.
  -h, --help
    Show this help.
  -q, --quiet
    Be more quiet. Can be repeated to increase silence.
  -u, --upstream
    Set local branches to track remote branches as upstream, similar 
    functionality to "git branch -u" and "git push -u". If several 
    remotes are specified, the last remote in alphabetical order is 
    used.
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.

END
    exit 0
fi

remotes=origin
test "$opt_all" = "1" && remotes=$(git remote)
unset create_dangling
test "$opt_commit_branches" = "1" && create_dangling=1
unset force_str
test "$opt_force" = "1" && force_str="--force"
unset upstream_str
test "$opt_upstream" = "1" && upstream_str="-u"
test -z "$1" || remotes="$@"
echo
is_bare=1
test "$(git config --get core.bare)" = "true" || is_bare=0
t_el="$(tput el)"
for remote in $remotes; do
    echo ==== $progname: remote $remote
    for f in $(
        git branch -a |
            grep remotes/$remote/ |
            grep -v -E "remotes/$remote/HEAD( |\$)" |
            perl -pe "s!remotes/$remote/(.*)\$!\$1!"
    ); do
        if test $opt_verbose -gt 0; then
            echo -ne "$f$t_el\\r"
        fi
        test "$create_dangling" != "1" &&
            echo $f | grep -qE '^commit-[0-9a-f]{40}$' &&
                test "$is_bare" = "0" && continue
        (
            git branch --no-track $f $remote/$f 2>&1 &&
                echo $progname: Created $f
        ) | grep -v '^fatal: A branch named .* already exists.'
        git push . $remote/$f:refs/heads/$f $force_str 2>&1 |
            grep -v '^Everything up-to-date'
        test -n "$upstream_str" && git branch -u $remote/$f $f
    done
    tput el
    echo
done
