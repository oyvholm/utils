#!/bin/bash

#=======================================================================
# git-allbr
# File ID: b8c0ee54-eb71-11df-a07a-fefdb24f8e10
#
# Create local Git branches that only exist on remotes and update local 
# branches against remote branches.
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#=======================================================================

progname=git-allbr
VERSION=0.2.0

if test "$1" = "--version"; then
    echo $progname $VERSION
    exit 0
fi

if test "$1" = "-h" -o "$1" = "--help"; then
    cat <<END

Create local Git branches that only exist on remotes and update local 
branches against remote branches.

Usage: $progname [options] [remote [remotes [...]]]

Options:

  -a
    Create branches from all remotes. If this option is not specified, 
    only "origin" or remotes specified on the command line are scanned.
  -c
    Also create commit-* branches created by git-dangling.
  -f
    Allow rewriting of local branches, override fast-forwarding.
  -h, --help
    Show this help.
  -u
    Set local branches to track remote branches as upstream, similar 
    functionality to "git branch -u" and "git push -u". If several 
    remotes are specified, the last remote in alphabetical order is 
    used.
  --version
    Print version information.

END
    exit 0
fi

remotes=origin
test "$1" = "-a" && { remotes=$(git remote); shift; }
unset create_dangling
test "$1" = "-c" && { create_dangling=1; shift; }
unset force_str
test "$1" = "-f" && { force_str="--force"; shift; }
unset upstream_str
test "$1" = "-u" && { upstream_str="-u"; shift; }
test -z "$1" || remotes="$@"
echo
is_bare=1
test "$(git config --get core.bare)" = "true" || is_bare=0
for remote in $remotes; do
    echo ==== $progname: remote $remote
    for f in $(git branch -a | grep remotes/$remote/ | grep -v -E "remotes/$remote/HEAD( |\$)" | perl -pe "s!remotes/$remote/(.*)\$!\$1!"); do
        test "$create_dangling" != "1" && echo $f | grep -qE '^commit-[0-9a-f]{40}$' && test "$is_bare" = "0" && continue
        (git branch --no-track $f $remote/$f 2>&1 && echo $progname: Created $f) | grep -v '^fatal: A branch named .* already exists.'
        git push . $remote/$f:refs/heads/$f $force_str 2>&1 | grep -v '^Everything up-to-date'
        test -n "$upstream_str" && git branch -u $remote/$f $f
    done
    echo
done
