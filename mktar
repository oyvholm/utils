#!/usr/bin/env bash

#=======================================================================
# mktar
# File ID: 5818b856-0ba9-11de-b2c1-000475e441b9
#
# Move a whole subdirectory tree into a single .tar.gz file.
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#=======================================================================

progname=mktar
VERSION=0.31.2

STD_SUFFIX=''

ARGS="$(getopt -o "\
1\
A\
G\
L\
O\
P:\
S:\
X\
d\
f\
h\
i\
m\
o:\
q\
r\
s:\
v\
x\
z\
" -l "\
dereference,\
dirs-only,\
force,\
gzip,\
help,\
incremental,\
no-actime,\
no-git-check,\
no-sparse,\
no-uuid,\
no-xattrs,\
numeric-owner,\
output-dir:,\
prefix:,\
quiet,\
random-mac,\
remove-files,\
rsyncable,\
split:,\
stdout,\
suffix:,\
verbose,\
version,\
xz,\
" -n "$progname" -- "$@")"
test "$?" = "0" || exit 1
eval set -- "$ARGS"

opt_1=0
opt_dereference=0
opt_dirs_only=0
opt_force=0
opt_gzip=0
opt_help=0
opt_incremental=0
opt_no_actime=0
opt_no_git_check=0
opt_no_sparse=0
opt_no_uuid=0
opt_no_xattrs=0
opt_numeric_owner=0
opt_output_dir=''
opt_prefix=''
opt_quiet=0
opt_random_mac=0
opt_remove_files=0
opt_rsyncable=0
opt_split=''
opt_stdout=0
opt_suffix="$STD_SUFFIX"
opt_verbose=0
opt_xz=0
while :; do
    case "$1" in
        --no-sparse) opt_no_sparse=1; shift ;;
        --no-uuid) opt_no_uuid=1; shift ;;
        --numeric-owner) opt_numeric_owner=1; shift ;;
        --rsyncable) opt_rsyncable=1; shift ;;
        --version) echo $progname $VERSION; exit 0 ;;
        -1) opt_1=1; shift ;;
        -A|--no-actime) opt_no_actime=1; shift ;;
        -G|--no-git-check) opt_no_git_check=1; shift ;;
        -L|--dereference) opt_dereference=1; shift ;;
        -O|--stdout) opt_stdout=1; shift ;;
        -P|--prefix) opt_prefix="$2"; shift 2 ;;
        -S|--suffix) opt_suffix="$2"; shift 2 ;;
        -X|--no-xattrs) opt_no_xattrs=1; shift ;;
        -d|--dirs-only) opt_dirs_only=1; shift ;;
        -f|--force) opt_force=1; shift ;;
        -h|--help) opt_help=1; shift ;;
        -i|--incremental) opt_incremental=1; shift ;;
        -m|--random-mac) opt_random_mac=1; shift ;;
        -o|--output-dir) opt_output_dir="$2"; shift 2 ;;
        -q|--quiet) opt_quiet=$(($opt_quiet + 1)); shift ;;
        -r|--remove-files) opt_remove_files=1; shift ;;
        -s|--split) opt_split="$2"; shift 2 ;;
        -v|--verbose) opt_verbose=$(($opt_verbose + 1)); shift ;;
        -x|--xz) opt_xz=1; shift ;;
        -z|--gzip) opt_gzip=1; shift ;;
        --) shift; break ;;
        *) echo $progname: Internal error >&2; exit 1 ;;
    esac
done
opt_verbose=$(($opt_verbose - $opt_quiet))

if [ -n "$POSIXLY_CORRECT" ]; then
    tput bold
    tput setaf 1
    echo $progname: POSIXLY_CORRECT = \"$POSIXLY_CORRECT\" >&2
    tput sgr0
fi

if test "$opt_help" = "1"; then
    test $opt_verbose -gt 0 && { echo; echo $progname $VERSION; }
    cat <<END

Create a .tar file of a file or directory with optional UUID label, 
prefix, suffix, splitting, or compression.

Usage: $progname [options] FILE_OR_DIRECTORY [...]

Options:

  -1
    Alias for "--split 1G". No modern file systems should have any 
    problems with this size, and it makes it easy to calculate the size 
    of the .tar file.
  -d, --dirs-only
    Ignore non-directory arguments.
  -f, --force
    Don't abort if the .tar file exists, delete it before proceeding.
  -G, --no-git-check
    To protect against potential data loss, it first loops through all 
    arguments to check that none of them are stored in Git. If any files 
    are stored under any of the directories, it aborts. Useful with for 
    example git-annex, where only a symlink would be stored in the 
    archive file. This option disables the check.
  -h, --help
    Show this help.
  -i, --incremental
    Create a .snar file with information for creating incremental 
    backups. Uses the -g/--listed-incremental option in GNU tar.
  -L, --dereference
    Don't pack symlinks, include the actual files they point to.
  -m, --random-mac
    Use random MAC address in UUID file label.
  --no-sparse
    Don't create sparse tar file.
  --no-uuid
    Don't create UUID label in the .tar file.
  --numeric-owner
    Use numbers for user/group names.
  -O, --stdout
    Send the .tar output to stdout instead of creating files on disk. 
    All nonsensical options are ignored, for example --split. Does not 
    work with compression.
  -o DIR, --output-dir DIR
    Store the tar files in DIR instead of the current directory.
  -P PREFIX, --prefix PREFIX
    Use PREFIX at the beginning of the tar filenames. Doesn't change the 
    name of the extracted files. Adds a terminating '.' if it doesn't 
    exist.
  -q, --quiet
    Be more quiet. Can be repeated to increase silence.
  -r, --remove-files
    Remove files in DIRECTORY immediately after they've been added to 
    the archive. Can be used when there's not enough disk space for the 
    archive.
  --rsyncable
    Use --rsyncable option with gzip.
  -S SUFFIX, --suffix SUFFIX
    Add a custom suffix after the directory name and before the .tar 
    extension in the output filename. No changes are made to the 
    resulting tar file, only the file name is different. An intial '.' 
    is added if it's missing.
    Default value: "$STD_SUFFIX".
  -s SIZE, --split SIZE
    Split the .tar file into files with SIZE bytes each. Allowed values 
    are those understood by the -b/--bytes option in split(1). These 
    files are not compressed by default, to make it easier to extract 
    data from the files without starting from the beginning.
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.
  -A, --no-actime
    Don't store the access time or creation time of the members in the 
    tar archive. Use with --no-uuid to generate identical tar files.
  -X, --no-xattrs
    Don't use --xattrs with tar(1), create standard tar archive without 
    extended attributes and nanoseconds.
  -x, --xz
    Compress the archives with xz(1) after the files are added.
  -z, --gzip
    Compress the archives with gzip(1) after the files are added.

END
    exit 0
fi

if test "$opt_xz" = "1" -a "$opt_gzip" = "1"; then
    echo $progname: Cannot mix the --gzip and --xz options >&2
    exit 1
fi

if test "$opt_1" = "1" -a -n "$opt_split"; then
    echo $progname: Cannot mix the -1 and --split options >&2
    exit 1
fi

if test "$opt_stdout" = "1" -a -n "$(echo $opt_gzip$opt_xz | grep 1)"; then
    echo $progname: Cannot use compression with -O/--stdout >&2
    exit 1
fi

test "$opt_1" = "1" && opt_split=1G

if test "$opt_dereference" = "1"; then
    dereference_str="--dereference"
else
    dereference_str=""
fi

if test "$opt_no_actime" = "1"; then
    actime_str="--pax-option=delete=atime,delete=ctime"
else
    actime_str=""
fi

if test "$opt_random_mac" = "1"; then
    random_mac_str="--random-mac"
else
    random_mac_str=""
fi

if test "$opt_rsyncable" = "1"; then
    if [ "$opt_gzip" = "0" ]; then
        echo "$progname: --rsyncable needs the -z/--gzip option" >&2
        exit 1
    fi
    rsyncable_str="--rsyncable"
else
    rsyncable_str=""
fi

if test "$opt_no_sparse" = "1"; then
    sparse_str=""
else
    sparse_str="--sparse"
fi

if [ "$opt_no_uuid" = "0" -a -z "$(suuid --version 2>/dev/null)" ]; then
    echo "$progname: suuid is not installed, use --no-uuid" >&2
    exit 1
fi

if test "$opt_remove_files" = "1"; then
    rm_files_str="--remove-files"
else
    rm_files_str=""
fi

if test "$opt_no_xattrs" = "1"; then
    xattrs_str=""
else
    xattrs_str="--xattrs"
fi

if test "$opt_numeric_owner" = "1"; then
    numeric_str="--numeric-owner"
else
    numeric_str=""
fi

for f in "$@"; do
    if test -d "$f" -o "$opt_dirs_only" != "1"; then
        if test "$opt_no_git_check" != "1"; then
            git ls-files "$f" | grep -q . >&2 && {
                echo -n "$progname: $f: " >&2
                if test -d "$f"; then
                    echo Files are stored in Git below this directory >&2
                else
                    echo File is stored in Git >&2
                fi
                echo $progname: Use -G/--no-git-check to add it anyway >&2
                exit 1
            }
        fi
    else
        echo $progname: $f: Not a directory >&2
    fi
done

prefix="$opt_prefix"
if test -n "$prefix"; then
    echo "$prefix" | grep -q '\.$' || prefix="$prefix."
fi

suffix="$opt_suffix"
if test -n "$suffix"; then
    echo "$suffix" | grep -q '^\.' || suffix=".$suffix"
fi

if test -n "$opt_output_dir"; then
    if test ! -d "$opt_output_dir/."; then
        echo "$progname: $opt_output_dir: Directory not found" >&2
        exit 1
    fi
    output_dir="$opt_output_dir/"
else
    output_dir="";
fi

for f in "$@"; do
    dir="$(echo -n "$f" | sed 's/\/*$//')"
    if [ -z "$dir" ]; then
        echo "$progname: $f: Argument is empty after stripping slash" >&2
        exit 1
    fi
    tarfile="$output_dir$prefix$dir$suffix.tar"

    if test $opt_verbose -ge 2; then
        echo $progname: dir = $dir >&2
    fi

    if [ -d "$dir" -o "$opt_dirs_only" != "1" ]; then
        echo >&2
        echo $progname: Packing $dir... >&2

        if test "$opt_stdout" != "1"; then
            if ls "$tarfile"* 2>/dev/null | grep -q .; then
                if test "$opt_force" = "1"; then
                    rm -fv "$tarfile"*
                else
                    echo "$progname: $tarfile* already exist" >&2
                    exit 1
                fi
            fi
        fi

        echo "$dir" | grep -q / && {
            echo "$progname: $dir: Slashes not allowed in the file name" >&2
            exit 1
        }

        if test "$opt_no_uuid" = "1"; then
            label_str=""
        else
            uuid=$(
                suuid -t mktar --raw -w eo $random_mac_str \
                    -c "<c_mktar> <filename>$tarfile</filename> <host>$(
                        hostname
                    )</host> <directory>$(/bin/pwd)</directory> </c_mktar>"
            ) || {
                echo $progname: suuid error >&2
                exit 1
            }
            label_str="--label=$uuid"
        fi
        if test "$opt_incremental" = "1"; then
            incremental_str="--listed-incremental $prefix$dir$suffix.snar"
        else
            incremental_str=""
        fi
        tar_args="$incremental_str $rm_files_str"
        tar_args="$tar_args --force-local $actime_str --sort=name $sparse_str"
        tar_args="$tar_args $dereference_str $numeric_str $xattrs_str"
        tar_args="$tar_args $label_str"
        if test "$opt_stdout" = "1"; then
            echo $progname: Sending to stdout >&2
            echo $progname: tar c $tar_args $dir >&2
            tar c $tar_args "$dir" || exit 1
            continue
        fi
        if test -n "$opt_split"; then
            echo $progname: tar c $tar_args $dir \
                 \| split -b $opt_split --verbose - $tarfile.split_ >&2
            tar c $tar_args "$dir" \
            | split -b $opt_split --verbose - "$tarfile.split_" || exit 1
            if test ! -e "$tarfile.split_ab"; then
                mv -vi "$tarfile.split_aa" "$tarfile" || exit 1
            fi
            test "$opt_xz" = "1" && xz -v "$tarfile"*
            test "$opt_gzip" = "1" && gzip -vn $rsyncable_str "$tarfile"*
        else
            echo $progname: tar cf $tarfile $tar_args $dir >&2
            tar cf "$tarfile" $tar_args "$dir" || exit 1
            if test "$opt_stdout" != "1"; then
                wc -c "$tarfile" \
                | numfmt --to=si --format=%7.2f --round=nearest >&2
                test "$opt_xz" = "1" && xz -v "$tarfile"
                test "$opt_gzip" = "1" && gzip -vn $rsyncable_str "$tarfile"
            fi
        fi
    fi
done

exit 0
