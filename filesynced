#!/bin/bash

#=======================================================================
# filesynced
# File ID: 25796c28-7205-11e5-b257-fefdb24f8e10
#
# Add 'synced'-entry into synced.sqlite for files.
#
# Author: Ã˜yvind A. Holm <sunny@sunbase.org>
# License: GNU General Public License version 2 or later.
#=======================================================================

progname=filesynced
VERSION=0.4.0

SQLITE=sqlite3
bin="$HOME/bin"
db="synced.sqlite"

ARGS="$(getopt -o "hlp:qt:v" \
    -l \
"help,list,lock,set-priority:,quiet,"\
"random,type:,unlock,verbose,version" \
    -n "$progname" -- "$@")"
test "$?" = "0" || exit 1
eval set -- "$ARGS"

opt_help=0
opt_list=0
opt_lock=0
opt_set_priority=''
opt_quiet=0
opt_random=0
opt_type='%'
opt_unlock=0
opt_verbose=0
while :; do
    case "$1" in
        (-h|--help) opt_help=1; shift ;;
        (-l|--list) opt_list=1; shift ;;
        (--lock) opt_lock=1; shift ;;
        (-p|--set-priority) opt_set_priority=$2; shift 2 ;;
        (-q|--quiet) opt_quiet=$(($opt_quiet + 1)); shift ;;
        (--random) opt_random=1; shift ;;
        (-t|--type) opt_type=$2; shift 2 ;;
        (--unlock) opt_unlock=1; shift ;;
        (-v|--verbose) opt_verbose=$(($opt_verbose + 1)); shift ;;
        (--version) echo $progname $VERSION; exit 0 ;;
        (--) shift; break ;;
        (*) echo $progname: Internal error >&2; exit 1 ;;
    esac
done
opt_verbose=$(($opt_verbose - $opt_quiet))

if test "$opt_help" = "1"; then
    test $opt_verbose -gt 0 && { echo; echo $progname $VERSION; }
    cat <<END

Add 'synced'-entry into $db for files. Updates synced.rev and 
synced.date with Git commit info.

Usage: $progname [options] commit file [file [...]]
       $progname -l [-t TYPE]
       $progname -p NEWPRI file [files [...]]
       $progname --lock
       $progname --unlock TOKEN

Options:

  -h, --help
    Show this help.
  -l, --list
    Create a file list sorted by how many revisions they are behind the 
    files in Lib/std/ in current HEAD.
  --lock
    Create $db from synced.sql and activate locking. A lock
    token is sent to stdout, and this token is needed to unlock.
  -p NEWPRI, --set-priority NEWPRI
    Change todo priority for files specified on the command line. NEWPRI 
    must be between 1 and 5.
  -q, --quiet
    Be more quiet. Can be repeated to increase silence.
  --random
    Pick a random file from the todo list and sync it using "vd".
  -t FILETYPE. --type FILETYPE
    Limit list to files of type FILETYPE, for example "bash" or 
    "perl-tests". SQL LIKE wildcards can be used, like '%' and '_'.
  --unlock TOKEN
    If TOKEN is correct, overwrite synced.sql with the contents from 
    $db, delete synced.slite and remove lock.
  -v, --verbose
    Increase level of verbosity. Can be repeated.
  --version
    Print version information.

END
    exit 0
fi

msg() {
    local empty_line=
    local no_lf=
    if test "$1" = "-l"; then
        # If -l is specified, create empty line before message
        empty_line=1
        shift
    fi
    if test "$1" = "-n"; then
        # If -n is first argument, don't terminate with \n
        no_lf="-n"
        shift
    fi
    local vlevel=$1
    shift
    test $vlevel -gt $opt_verbose && return;
    test "$empty_line" = "1" && echo >&2
    echo $no_lf "$progname $$:$BASH_LINENO: $*" >&2
    return
}

msg -l 2 Starting $progname, pwd = $(pwd)

repotop="$(git rev-parse --show-toplevel)"
msg 2 repotop = \"$repotop\"
lockdir="$repotop/synced.sql.lock"
msg 2 lockdir = \"$lockdir\"

cleanup() {
    msg 2 "cleanup(): bintoken = $bintoken"
    if test -n "$bintoken"; then
        msg 2 Unlock bintoken
        cd "$bin" && filesynced --unlock $bintoken
    fi
    msg 2 Unlock token
    cd "$repotop" && filesynced --unlock $token
}

safe_chdir() {
    local dir="$1"
    msg 2 chdir $dir
    cd "$dir" || {
        echo $progname: Cannot chdir to \'$dir\' >&2
        exit 1
    }
}

if test "$opt_lock" = "1" -a "$opt_unlock" = "1"; then
    echo $progname: Cannot mix --lock and --unlock >&2
    exit 1
fi

if test "$opt_lock" = "1"; then
    msg 2 Perform --lock stuff
    cd "$repotop" || {
        echo $progname --lock: $repotop: chdir error >&2
        exit 1
    }
    until mkdir "$lockdir" 2>/dev/null; do
        echo $progname --lock: $lockdir: Waiting for lockdir... >&2
        sleep 2
    done
    if test -e "$db"; then
        echo $progname --lock: $repotop/$db: File already exists >&2
        rmdir "$lockdir"
        exit 1
    fi
    if test -f "synced.sql"; then
        msg 2 Create $db from $(pwd)/synced.sql
        $SQLITE "$db" <synced.sql
    else
        echo $progname --lock: $repotop/$db: Database not found >&2
        rmdir "$lockdir"
        exit 1
    fi
    token="token_$(date -u +"%Y%m%dT%H%M%SZ").$$.$(
        head -c 20 /dev/urandom | sha1sum | head -c 40
    )"
    echo $token >"$lockdir/token"
    echo $token
    exit 0
fi

if test "$opt_unlock" = "1"; then
    msg 2 Perform --unlock stuff
    token_from_user="$1"
    msg 2 token_from_user = $token_from_user
    cd "$repotop" || {
        echo $progname --unlock: $repotop: chdir error >&2
        exit 1
    }
    if test ! -d "$lockdir"; then
        echo $progname --unlock: $lockdir: Lockdir doesn\'t exist >&2
        exit 1
    fi
    if test -e "$lockdir/token"; then
        msg 2 $lockdir/token exists
        realtoken=$(cat $lockdir/token)
        msg 2 realtoken = $realtoken
        if test "$token_from_user" != "$realtoken"; then
            echo $progname --unlock: Token mismatch >&2
            msg 2 Got $token_from_user
            msg 2 Expected $realtoken
            exit 1
        fi
        msg 2 Token is valid, delete $lockdir/token
        rm "$lockdir/token"
    fi
    if test -f "$db"; then
        sort-sqlite "$db"
        msg 2 Dump $db to $(pwd)/synced.sql
        $SQLITE "$db" .dump >synced.sql
        msg 2 Remove $db
        rm "$db"
    else
        msg 1 $db not found, did not update synced.sql
    fi
    if rmdir "$lockdir"; then
        msg 2 $lockdir removed
        exit 0
    else
        echo $progname --unlock: $lockdir: Could not remove lockdir >&2
        exit 1
    fi
fi

bintoken=
token=$(filesynced --lock)
if test -z "$(echo $token | grep ^token_)"; then
    echo $progname: No token received from filesynced --lock >&2
    exit 1
fi
trap cleanup EXIT
msg 2 token = $token

test -f "$db" || {
    echo $progname: $db: Sync database not found >&2
    exit 1
}

if test "$opt_list" = "1"; then
    msg 2 Perform --list stuff
    test -n "$opt_type" && type_str="$opt_type" || type_str="%"
    safe_chdir "$bin"
    if test "$(cat synced.sql.lock/token 2>/dev/null)" != "$token"; then
        msg 2 token is different from synced.sql.lock/token
        bintoken=$(filesynced --lock)
        msg 2 bintoken = $bintoken
        if test -z "$(echo $bintoken | grep ^token_)"; then
            echo -n "$progname: No token received " >&2
            echo from filesynced --lock in $bin >&2
            exit 1
        fi
    fi
    safe_chdir - >/dev/null
    cat <<END | $SQLITE "$db" | bash | sort -n
SELECT
  'echo \$(' ||
    'cd "$bin"; git log --format=%h ' || rev || '.. ' || orig || ' | wc -l' ||
  ') ' ||
  file ||
  ' "(' ||
    'cd ~/bin && git diff ' ||
    '\$(cd "$bin"; git log -1 --format=%h ' || rev || ')' ||
    '.. ' ||
    orig ||
  ') | patch -m ' || file || ' && filesynced HEAD ' || file || '";'
FROM synced
WHERE
  orig LIKE 'Lib/std/$type_str'
  AND
  rev IS NOT NULL;
END
    exit
fi

if test "$opt_random" = "1"; then
    msg 2 Perform --random stuff
    file="$(
        $SQLITE "$db" "
SELECT file FROM todo
  ORDER BY pri, random()
  LIMIT 1;
        "
    )"
    if test -z "$file"; then
        echo $progname: No files to edit >&2
        exit 0
    fi
    vd "$file" "$HOME/bin/$(
        $SQLITE $db "
SELECT orig FROM synced
  WHERE file = '$file';
        "
    )"
    exit
fi

if test -n "$opt_set_priority"; then
    msg 2 Perform --set-priority stuff
    echo "$opt_set_priority" | grep -qE '^[1-5]$' || {
        echo $progname: Argument to -p/--set-priority must be between 1 and 5
        exit 1
    }
    (
        echo BEGIN\;
        for f in "$@"; do
            echo "UPDATE todo SET pri = $opt_set_priority WHERE file = '$f';"
        done
        echo END\;
    ) | $SQLITE "$db"
    exit
fi

commit="$(cd "$bin"; git rev-parse $1)"
if test -z "$commit"; then
    echo $progname: $1: Invalid Git ref >&2
    exit 1
fi
shift
files="$*"
if test -z "$files"; then
    echo $progname: No files specified >&2
    exit 1
fi
date="$(
    cd "$bin"
    git log -1 --format=%cd --date=raw $commit |
    cut -f 1 -d ' ' |
    ep -D ' ' |
    tr -d Z
)"

for f in $files; do
    if test -z "$(git ls-files "$f")"; then
        echo $progname: $f: File is not in Git, no entries updated >&2
        exit 1
    fi
done

(
    echo BEGIN\;
    for f in $files; do
        cat <<END
UPDATE synced
  SET rev = '$commit', date = '$date'
  WHERE file = '$f';
DELETE FROM todo
  WHERE file = '$f';
END
    done
    echo COMMIT\;
) | $SQLITE "$db"
